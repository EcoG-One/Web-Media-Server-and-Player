<!DOCTYPE html>
<html>
<head>
    <title>EcoG's Media Player</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="static/css/style.css">
    <style>
        /* Minimal inline styles for lyrics & list display & artists/albums */
        .lyrics { max-height: 240px; overflow-y: auto; padding: 10px; border: 1px solid #ddd; border-radius: 5px; background: #fff; }
        .lyrics-line { padding: 4px 6px; color: #333; }
        .lyrics-line.current { background: #333; color: #fff; border-radius: 3px; }
        .list-album { margin-bottom: 12px; }
        .list-song { padding: 4px 6px; border-bottom: 1px dashed #eee; cursor: pointer; }
        .artist-item, .album-item { display: inline-block; margin: 8px; vertical-align: top; width: 160px; cursor: pointer; text-align: center; }
        .album-cover { width: 150px; height: 150px; object-fit: cover; border-radius: 4px; border: 1px solid #ddd; display: block; margin: 0 auto 6px; }
        .artist-name { font-weight: bold; margin-bottom: 4px; }
        .hidden { display: none; }
        .controls-inline { display: inline-block; margin-left: 8px; }
        .next {font-family: inherit;
                -webkit-box-pack: center;
                justify-content: center;
                background: #f5f4ec;
                border: 1px solid #f5f4ec;
                border-radius: 4px;
                display: flex;
                cursor: pointer;
                -webkit-box-align: center;
                align-items: center;
                gap: 8px;
                padding: 8px 12px 8px 8px;
                width: 73px;
                height: 24px;}
        .icon {font-family: inherit;
                cursor: pointer;
                forced-color-adjust: auto;
                width: 10px;}
        .prevnext { color: #000;
                font-family: Helvetica Neue,Helvetica,Nimbus Sans,Arial,sans-serif;
                font-size: 14px;
                display: flex;
                -webkit-box-align: center;
                align-items: center;
                gap: 4px;
                -webkit-box-pack: center;
                justify-content: center;}
    </style>
</head>
<body>
    <h1>EcoG's Media Player</h1>

    <div class="menu">
        {% if is_localhost %}
        <button onclick="scanLibrary()">Scan Library</button>
        <button onclick="showSettings()">Settings</button>
        {% endif %}
        <button onclick="showPlayFromPlaylist()">Playlists</button>
        <button onclick="showPlayFile()">Search</button>

        <!-- New Buttons -->
        <button onclick="listSongs()">All Songs</button>
        <button onclick="listArtists()">All Artists</button>
        <button onclick="listAlbums()">All Albums</button>
        <button onclick="toggleLyricsPanel()">Show/Hide Lyrics</button>
      <!--  <button onclick="toggleLyricsSync()">Toggle Lyrics Sync</button> -->
    </div>

    <div id="content" class="content">
        <div id="status"></div>

        <div id="playlist-section" class="hidden">
                <label for="randomize">Play in Random Order</label>
                <input type="checkbox" id="randomize" name="randomize" value=0 onclick="this.value=this.checked ? '1' : '0';">
            <h3>Select Playlist</h3>
            <div id="playlist-list"></div>
        </div>

        <div id="list-section" class="hidden">
            <h3>All Songs (grouped by album)</h3>
            <div id="all-songs-list">Fetching all songs it may take some time, please wait...</div>
        </div>

        <div id="artists-section" class="hidden">
            <h3>Artists</h3>
            <div id="artists-list">Fetching all artists it may take some time, please wait...</div>
        </div>

        <div id="artist-albums-section" class="hidden">
            <h3 id="artist-name"></h3>
            <div id="artist-albums-list"></div>
        </div>

        <div id="albums-section" class="hidden">
            <h3>Albums</h3>
            <div class="prevnext">
            <label for="limit">Albums per Page:</label>
            <input type="number" value=100 min=1 max=9999 name="limit" id='limit' />
            <button onclick="listAlbums()" class="next">
                <svg viewBox="0 0 1024 1024" class="icon" role="img" aria-hidden="true">
                    <path d="M358 311q0 7-5 13L128 549l225 224q5 6 5 13t-5 13l-29 29q-6 6-13 6t-13-6L31 562q-5-6-5-13t5-14l267-266q5-6 13-6t13 6l29 29q5 5 5 13z">

                    </path>
                </svg>
                <!-- -->
                Prev
            </button>
            <button onclick="loadNextPage()" class="next">
                Next<!-- -->
                <svg viewBox="0 0 1024 1024" class="icon" role="img" aria-hidden="true">
                    <path d="M340 549q0 7-6 13L68 828q-6 6-13 6t-13-6l-29-29q-6-5-6-13t6-13l225-224L13 324q-6-6-6-13t6-13l29-29q5-6 13-6t13 6l266 266q6 6 6 14z"></path>
                </svg>
            </button>
            </div>
            <div id="albums-list">Fetching all albums it may take some time, please wait...</div>
        </div>

        <div id="search-section" class="hidden">
            <h3>Search Songs</h3>
            <select id="search-column">
                <option value="artist">Artist</option>
                <option value="song_title">Song Title</option>
                <option value="album">Album</option>
            </select>
            <input type="text" id="search-input" placeholder="Enter search term...">
            <button onclick="searchSongs()">Search</button>
            <div id="search-results"></div>
        </div>

        <div id="player-section" class="hidden">
            <!-- Gap Killer Controls -->
            <div class="gap-killer-controls" style="margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; border-radius: 5px; background-color: #f9f9f9;">
                <h4 style="margin: 0 0 10px 0;">Gap Killer Settings</h4>
                <label>
                    <input type="checkbox" id="gap-killer-enabled" checked> Enable Gap Killer (-46dB)
                </label>
                <div style="margin-top: 8px;">
                    <label for="silence-threshold">Silence Threshold: </label>
                    <input type="range" id="silence-threshold" min="-60" max="-20" value="-46" step="1">
                    <span id="threshold-display">-46dB</span>
                </div>
                <div style="margin-top: 8px;">
                    <label for="silence-duration">Minimum Silence Duration: </label>
                    <input type="range" id="silence-duration" min="0.1" max="5" value="0.5" step="0.1">
                    <span id="duration-display">0.5s</span>
                </div>
                <div id="silence-indicator" style="margin-top: 8px; padding: 5px; border-radius: 3px; background-color: #e8f5e8; color: #2d5016;">
                    Status: Active - Monitoring audio levels
                </div>
            </div>
            
            <div class="audio-player">
                <audio id="audio1" controls></audio>
                <audio id="audio2" controls></audio>
            </div>
            <div id="metadata" class="metadata"></div>

            <div id="lyrics-panel" class="hidden" style="margin-top:10px;">
                <h3>Lyrics <span class="controls-inline">
                    <label><input type="checkbox" id="sync-lyrics" checked> Sync</label>
                </span></h3>
                <div id="lyrics" class="lyrics"></div>
            </div>

            <div id="playlist-display" class="playlist-display hidden">
                <h3 id="playlist_name"></h3>
                <div id="playlist-songs"></div>
            </div>
        </div>
    </div>

<script>
        let offset = 0;
        let currentAudio = 1;
        let playlist = [];
        let currentIndex = 0;
        let crossfadeTime = {{settings.crossfade_time}};
        let playlistMetadata = [];
        let playedSongs = new Set();
        
        // Add state management for preventing race conditions
        let isTransitioning = false;
        let crossfadeActive = false;
        let currentEventListeners = new Map(); // Track active listeners

        // Lyrics state
        window.currentLyrics = []; // [{time: seconds, text: "..."}]
        window.lyricsSyncEnabled = true;
        window.currentLyricIndex = -1;

        // Gap Killer variables
        let audioContext = null;
        let analyser1 = null;
        let analyser2 = null;
        let source1 = null;
        let source2 = null;
        let silenceStartTime = null;
        let gapKillerEnabled = true;
        let silenceThreshold = -46; // dB
        let minimumSilenceDuration = 0.5; // seconds
        let audioAnalysisInterval = null;

        // Initialize Gap Killer controls
        function initializeGapKillerControls() {
            const enabledCheckbox = document.getElementById('gap-killer-enabled');
            const thresholdSlider = document.getElementById('silence-threshold');
            const durationSlider = document.getElementById('silence-duration');
            const thresholdDisplay = document.getElementById('threshold-display');
            const durationDisplay = document.getElementById('duration-display');

            enabledCheckbox.addEventListener('change', (e) => {
                gapKillerEnabled = e.target.checked;
                updateSilenceIndicator(gapKillerEnabled ? 'Active - Monitoring audio levels' : 'Disabled', 
                                     gapKillerEnabled ? '#e8f5e8' : '#f5e8e8',
                                     gapKillerEnabled ? '#2d5016' : '#501616');
            });

            thresholdSlider.addEventListener('input', (e) => {
                silenceThreshold = parseInt(e.target.value);
                thresholdDisplay.textContent = `${silenceThreshold}dB`;
            });

            durationSlider.addEventListener('input', (e) => {
                minimumSilenceDuration = parseFloat(e.target.value);
                durationDisplay.textContent = `${minimumSilenceDuration.toFixed(1)}s`;
            });
        }

        function updateSilenceIndicator(text, bgColor = '#e8f5e8', color = '#2d5016') {
            const indicator = document.getElementById('silence-indicator');
            if (indicator) {
                indicator.textContent = `Status: ${text}`;
                indicator.style.backgroundColor = bgColor;
                indicator.style.color = color;
            }
        }

        // Initialize Web Audio API for audio analysis
        function initializeAudioAnalysis() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                const audio1 = document.getElementById('audio1');
                const audio2 = document.getElementById('audio2');

                // Create analysers
                analyser1 = audioContext.createAnalyser();
                analyser2 = audioContext.createAnalyser();
                
                analyser1.fftSize = 2048;
                analyser2.fftSize = 2048;

                // Create sources (will be connected when audio plays)
                if (!source1) {
                    source1 = audioContext.createMediaElementSource(audio1);
                    source1.connect(analyser1);
                    analyser1.connect(audioContext.destination);
                }
                
                if (!source2) {
                    source2 = audioContext.createMediaElementSource(audio2);
                    source2.connect(analyser2);
                    analyser2.connect(audioContext.destination);
                }

                startAudioAnalysis();
            } catch (error) {
                console.error('Error initializing audio analysis:', error);
                updateSilenceIndicator('Error - Audio analysis unavailable', '#f5e8e8', '#501616');
            }
        }

        // Start continuous audio level monitoring
        function startAudioAnalysis() {
            if (audioAnalysisInterval) {
                clearInterval(audioAnalysisInterval);
            }

            audioAnalysisInterval = setInterval(() => {
                if (!gapKillerEnabled || isTransitioning || crossfadeActive) return;

                const currentAudioElement = document.getElementById(`audio${currentAudio}`);
                const currentAnalyser = currentAudio === 1 ? analyser1 : analyser2;

                if (currentAudioElement && !currentAudioElement.paused && currentAnalyser) {
                    const audioLevel = getAudioLevel(currentAnalyser);
                    checkForSilence(audioLevel, currentAudioElement);
                }
            }, 100); // Check every 100ms
        }

        // Get current audio level in dB
        function getAudioLevel(analyser) {
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyser.getByteFrequencyData(dataArray);

            // Calculate RMS (Root Mean Square) value
            let sum = 0;
            for (let i = 0; i < bufferLength; i++) {
                const normalized = dataArray[i] / 255.0;
                sum += normalized * normalized;
            }
            const rms = Math.sqrt(sum / bufferLength);
            
            // Convert to decibels
            const db = rms > 0 ? 20 * Math.log10(rms) : -Infinity;
            return db;
        }

        // Check if current audio level indicates silence
        function checkForSilence(audioLevel, audioElement) {
            const currentTime = Date.now();

            if (audioLevel < silenceThreshold) {
                // Audio is below silence threshold
                if (silenceStartTime === null) {
                    silenceStartTime = currentTime;
                    updateSilenceIndicator(`Silence detected (${audioLevel.toFixed(1)}dB)`, '#fff3cd', '#856404');
                } else {
                    const silenceDuration = (currentTime - silenceStartTime) / 1000;
                    updateSilenceIndicator(`Silent for ${silenceDuration.toFixed(1)}s (${audioLevel.toFixed(1)}dB)`, '#fff3cd', '#856404');
                    
                    if (silenceDuration >= minimumSilenceDuration) {
                        // Trigger gap killer
                        triggerGapKiller(audioElement);
                    }
                }
            } else {
                // Audio is above silence threshold
                if (silenceStartTime !== null) {
                    updateSilenceIndicator(`Audio resumed (${audioLevel.toFixed(1)}dB)`, '#e8f5e8', '#2d5016');
                }
                silenceStartTime = null;
            }
        }

        // Trigger the gap killer to skip silence
        function triggerGapKiller(audioElement) {
            updateSilenceIndicator('Gap Killer activated - Skipping silence', '#d4edda', '#155724');
            
            // Find the next non-silent part or play next song
            const currentTime = audioElement.currentTime;
            const duration = audioElement.duration;
            if (duration - currentTime < 10) {
                playNextSong();
            } else {
                findNextAudioSection(audioElement);
            }

            
            // Reset silence detection
            silenceStartTime = null;
        }

        // Find and jump to the next section with audio
        function findNextAudioSection(audioElement) {
            const currentTime = audioElement.currentTime;
            const duration = audioElement.duration;
            
            // Jump forward by small increments to find audio
            const jumpIncrement = 1; // seconds
            let searchTime = Math.min(currentTime + jumpIncrement, duration - 5);
            
            // Set new playback position
            audioElement.currentTime = searchTime;
            
            updateSilenceIndicator('Jumped forward - Resuming playback', '#e8f5e8', '#2d5016');
        }

        // Resume AudioContext if suspended (required for some browsers)
        function resumeAudioContext() {
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume().then(() => {
                    console.log('AudioContext resumed');
                });
            }
        }

        function scanLibrary() {
            document.getElementById('status').innerHTML = 'Please select a Folder to scan for music.<BR>The Scan may take a while, depending on the library size.';
            fetch('/scan_library', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({"folder_path": null})
        })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        document.getElementById('status').innerHTML = data.message;
                    } else {
                        document.getElementById('status').innerHTML = 'Error: ' + data.error;
                    }
                });
        }

        function showPlayFromPlaylist() {
            document.getElementById('status').innerHTML = '';
            hideAllSections();
            document.getElementById('playlist-section').classList.remove('hidden');
            loadPlaylists();
        }

        function showPlayFile() {
            document.getElementById('status').innerHTML = '';
            hideAllSections();
            document.getElementById('search-section').classList.remove('hidden');
        }

        function showSettings() {
            window.location.href = '/settings';
        }

        function hideAllSections() {
            document.getElementById('playlist-section').classList.add('hidden');
            document.getElementById('search-section').classList.add('hidden');
            document.getElementById('player-section').classList.add('hidden');
            document.getElementById('list-section').classList.add('hidden');
            document.getElementById('artists-section').classList.add('hidden');
            document.getElementById('artist-albums-section').classList.add('hidden');
            document.getElementById('albums-section').classList.add('hidden');
            document.getElementById('lyrics-panel').classList.add('hidden');
        }

        function loadPlaylists() {
            fetch('/get_playlists')
                .then(response => response.json())
                .then(data => {
                    const listDiv = document.getElementById('playlist-list');
                    listDiv.innerHTML = '';
                    data.forEach(playlist => {
                        const div = document.createElement('div');
                        div.className = 'playlist-item';
                        div.textContent = playlist.name;
                        div.onclick = () => loadPlaylist(playlist.id);
                        listDiv.appendChild(div);
                    });
                });
        }

        function shuffleArray(array) {
          for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
          }
          return array;
        }

        function loadPlaylist(playlistId) {
            fetch(`/load_playlist/${playlistId}`)
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        playlist = data.playlist;
                        if (document.getElementById('randomize').value == 1) {
                            shuffleArray(playlist)
                        }
                        currentIndex = 0;
                        playedSongs.clear();
                        playlistMetadata = [];
                        isTransitioning = false;
                        crossfadeActive = false;
                        showPlayerSection();
                        loadPlaylistMetadata();
                        document.getElementById('playlist_name').innerHTML = data.name
                        playCurrentSong();
                    } else {
                        document.getElementById('status').innerHTML = 'Error: ' + data.error;
                    }
                });
        }

        function searchSongs() {
            const column = document.getElementById('search-column').value;
            const query = document.getElementById('search-input').value;

            if (!query) return;

            fetch(`/search_songs?column=${column}&query=${encodeURIComponent(query)}`)
                .then(response => response.json())
                .then(data => {
                    const resultsDiv = document.getElementById('search-results');
                    resultsDiv.innerHTML = '';

                    if (data.error) {
                        resultsDiv.innerHTML = 'Error: ' + data.error;
                        return;
                    }

                    if (data.length === 0) {
                        resultsDiv.innerHTML = 'No songs found.';
                        return;
                    }

                    // Add "Play All" button
                    const playAllDiv = document.createElement('div');
                    playAllDiv.style.marginBottom = '10px';
                    playAllDiv.innerHTML = `
                        <button onclick="playSearchResults()" style="padding: 8px 16px; background-color: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer;">
                            Play All (${data.length} songs)
                        </button>
                    `;
                    resultsDiv.appendChild(playAllDiv);

                    // Store search results globally
                    window.searchResults = data;

                    data.forEach((song, index) => {
                        const div = document.createElement('div');
                        div.className = 'search-result';
                        div.innerHTML = `
                            <span class="song-number">${index + 1}.</span>
                            <strong>${song.artist}</strong> - ${song.title} (${song.album})
                        `;
                        div.onclick = () => playSearchResultsFrom(index);
                        resultsDiv.appendChild(div);
                    });
                });
        }

        function playSingleSong(filePath) {
            playlist = [filePath];
            currentIndex = 0;
            playedSongs.clear();
            playlistMetadata = [];
            isTransitioning = false;
            crossfadeActive = false;
            showPlayerSection();
            playCurrentSong();
        }

        function showPlayerSection() {
            hideAllSections();
            document.getElementById('player-section').classList.remove('hidden');
            if (playlist.length > 1) {
                document.getElementById('playlist-display').classList.remove('hidden');
            }
            
            // Initialize gap killer when player section is shown
            if (!audioContext) {
                initializeAudioAnalysis();
            }
        }

        // Event listener management
        function removeAllEventListeners() {
            const audio1 = document.getElementById('audio1');
            const audio2 = document.getElementById('audio2');
            
            // Remove all tracked listeners
            currentEventListeners.forEach((listeners, audioId) => {
                const audio = document.getElementById(audioId);
                listeners.forEach(({event, handler}) => {
                    audio.removeEventListener(event, handler);
                });
            });
            
            // Clear the tracking map
            currentEventListeners.clear();
        }

        function addEventListenerTracked(audioId, event, handler) {
            const audio = document.getElementById(audioId);
            audio.addEventListener(event, handler);
            
            // Track the listener
            if (!currentEventListeners.has(audioId)) {
                currentEventListeners.set(audioId, []);
            }
            currentEventListeners.get(audioId).push({event, handler});
        }

        function playCurrentSong() {
            if (currentIndex >= playlist.length) return;
            if (isTransitioning) return; // Prevent multiple simultaneous calls

            const currentSong = playlist[currentIndex];
            const audio = document.getElementById(`audio${currentAudio}`);

            // Reset states
            isTransitioning = true;
            crossfadeActive = false;
            silenceStartTime = null; // Reset gap killer state

            // Clean up any existing listeners
            removeAllEventListeners();

            // Reset volume to full for the current song
            audio.volume = 1;

            // Stop any other audio that might be playing
            const otherAudio = document.getElementById(`audio${currentAudio === 1 ? 2 : 1}`);
            otherAudio.pause();
            otherAudio.currentTime = 0;

            // Set the source and play
            audio.src = `/serve_audio/${encodeURIComponent(currentSong)}`;
            audio.play().then(() => {
                // Resume audio context for gap killer
                resumeAudioContext();
                
                // Mark current song as played
                playedSongs.add(currentIndex);

                // Update playlist display
                updatePlaylistDisplay();

                // Setup next song handling
                setupNextSong();
                
                isTransitioning = false;
            }).catch(error => {
                console.error('Error playing song:', error);
                isTransitioning = false;
            });

            // Load metadata
            fetch(`/get_song_metadata/${encodeURIComponent(currentSong)}`)
                .then(response => response.json())
                .then(data => {
                    if (!data.error) {
                        displayMetadata(data);
                    } else {
                        clearLyricsDisplay();
                    }
                }).catch(() => {
                    clearLyricsDisplay();
                });
        }

        function setupNextSong() {
            const currentAudioId = `audio${currentAudio}`;
            const currentAudioElement = document.getElementById(currentAudioId);
            
            let hasStartedCrossfade = false;

            // Create the timeupdate handler
            const timeUpdateHandler = function() {
                if (isTransitioning) return; // Prevent actions during transitions
                
                const timeLeft = this.duration - this.currentTime;
                if (timeLeft <= crossfadeTime && currentIndex + 1 < playlist.length && !hasStartedCrossfade && !crossfadeActive) {
                    hasStartedCrossfade = true;
                    startCrossfade();
                }
            };

            // Create the ended handler
            const endedHandler = function() {
                if (isTransitioning) return; // Prevent multiple calls
                
                // Small delay to ensure crossfade logic completes if active
                setTimeout(() => {
                    if (!crossfadeActive) {
                        playNextSong();
                    }
                }, 100);
            };

            // Add tracked event listeners
            addEventListenerTracked(currentAudioId, 'timeupdate', timeUpdateHandler);
            addEventListenerTracked(currentAudioId, 'ended', endedHandler);
        }

        function startCrossfade() {
            if (currentIndex + 1 >= playlist.length) return;
            if (crossfadeActive) return; // Prevent multiple crossfades

            crossfadeActive = true;
            const currentAudioElement = document.getElementById(`audio${currentAudio}`);
            const nextAudio = currentAudio === 1 ? 2 : 1;
            const nextAudioElement = document.getElementById(`audio${nextAudio}`);
            const nextSong = playlist[currentIndex + 1];

            // Set up the next song
            nextAudioElement.src = `/serve_audio/${encodeURIComponent(nextSong)}`;
            if ({{settings.fade_in}} == 1) {
                nextAudioElement.volume = 0; // Start with volume at 0
            } else {nextAudioElement.volume = 1;
            }

            // Start playing the next song
            nextAudioElement.play().then(() => {
                // Begin crossfade
                performCrossfade(currentAudioElement, nextAudioElement);

                // Load metadata for next song (but don't display it yet)
                fetch(`/get_song_metadata/${encodeURIComponent(nextSong)}`)
                    .then(response => response.json())
                    .then(data => {
                        if (!data.error) {
                            // Store metadata for when the song officially starts
                            window.nextSongMetadata = data;
                        }
                    });
            }).catch(error => {
                console.error('Error starting next song:', error);
                crossfadeActive = false;
            });
        }

        function performCrossfade(currentAudio, nextAudio) {
            const fadeSteps = 20; // Number of volume adjustment steps
            const fadeInterval = (crossfadeTime * 1000) / fadeSteps; // Interval between steps in ms
            let step = 0;

            const fadeTimer = setInterval(() => {
                step++;
                const progress = step / fadeSteps;

                // Fade out current audio
                currentAudio.volume = Math.max(0, 1 - progress);

                // Fade in next audio
                if ({{settings.fade_in}} == 1) {
                    nextAudio.volume = Math.min(1, progress);
                }

                if (step >= fadeSteps) {
                    clearInterval(fadeTimer);
                    currentAudio.volume = 0;
                    nextAudio.volume = 1;
                    
                    // Trigger next song logic after crossfade completes
                    setTimeout(() => {
                        playNextSong();
                    }, 100);
                }
            }, fadeInterval);
        }

        function playNextSong() {
            if (isTransitioning) return; // Prevent multiple calls
            
            currentIndex++;
            if (currentIndex >= playlist.length) {
                crossfadeActive = false;
                return;
            }

            isTransitioning = true;
            currentAudio = currentAudio === 1 ? 2 : 1;
            const audio = document.getElementById(`audio${currentAudio}`);

            // Reset gap killer state for new song
            silenceStartTime = null;

            // Check if crossfade is active
            if (crossfadeActive) {
                // Song is already playing from crossfade, just update metadata and display
                audio.volume = 1; // Ensure volume is at full

                // Mark current song as played
                playedSongs.add(currentIndex);

                // Update playlist display
                updatePlaylistDisplay();

                // Display metadata if we have it from crossfade
                if (window.nextSongMetadata) {
                    displayMetadata(window.nextSongMetadata);
                    window.nextSongMetadata = null; // Clear it
                } else {
                    // Load metadata normally
                    const currentSong = playlist[currentIndex];
                    fetch(`/get_song_metadata/${encodeURIComponent(currentSong)}`)
                        .then(response => response.json())
                        .then(data => {
                            if (!data.error) {
                                displayMetadata(data);
                            }
                        });
                }

                // Reset crossfade flag
                crossfadeActive = false;
            } else {
                // Normal playback (no crossfade happened)
                const currentSong = playlist[currentIndex];
                
                // Stop the other audio
                const otherAudio = document.getElementById(`audio${currentAudio === 1 ? 2 : 1}`);
                otherAudio.pause();
                otherAudio.currentTime = 0;
                
                audio.volume = 1;
                audio.src = `/serve_audio/${encodeURIComponent(currentSong)}`;
                audio.play().then(() => {
                    // Resume audio context
                    resumeAudioContext();
                    
                    // Mark current song as played
                    playedSongs.add(currentIndex);

                    // Update playlist display
                    updatePlaylistDisplay();
                }).catch(error => {
                    console.error('Error playing next song:', error);
                });

                // Load metadata
                fetch(`/get_song_metadata/${encodeURIComponent(currentSong)}`)
                    .then(response => response.json())
                    .then(data => {
                        if (!data.error) {
                            displayMetadata(data);
                        }
                    });
            }

            // Setup next song handling
            setupNextSong();
            isTransitioning = false;
        }

        function displayMetadata(metadata) {
            const metadataDiv = document.getElementById('metadata');
            let html = '<h3>Now Playing</h3>';

            if (metadata.picture) {
                html += `<img src="data:image/jpeg;base64,${metadata.picture}" class="album-art"><br>`;
            }

            html += `<strong>Artist:</strong> ${metadata.artist}<br>`;
            html += `<strong>Title:</strong> ${metadata.title}<br>`;
            html += `<strong>Album:</strong> ${metadata.album}<br>`;
            html += `<strong>Year:</strong> ${metadata.year}<br>`;
            html += `<strong>Duration:</strong> ${Math.floor(metadata.duration / 60)}:${(metadata.duration % 60).toString().padStart(2, '0')}`;

            metadataDiv.innerHTML = html;
            document.title = metadata.artist + ' - ' + metadata.title;

            // Handle lyrics (both plain and synchronized)
            if (metadata.synchronized_lyrics) {
                const raw = metadata.synchronized_lyrics;
                const parsed = parseSynchronizedLyrics(raw);
                window.currentLyrics = parsed;
                renderLyrics(parsed);
                window.lyricsSyncEnabled = document.getElementById('sync-lyrics') ? document.getElementById('sync-lyrics').checked : true;
                if (window.lyricsSyncEnabled) startLyricsSync();
                document.getElementById('lyrics-panel').classList.remove('hidden');
            } else if (metadata.lyrics) {
                const raw = metadata.lyrics;
                window.currentLyrics = [{time: null, text: raw}];
                renderPlainLyrics(raw);
                document.getElementById('lyrics-panel').classList.remove('hidden');
                stopLyricsSync();
            } else {
                clearLyricsDisplay();
            }
        }

        function parseSynchronizedLyrics(raw) {
            const lines = raw.split(/\r?\n/);
            const parsed = [];
            const timeTagRegex = /\[(\d+):(\d+)(?:\.(\d+))?\](.*)/;
            lines.forEach(line => {
                const match = line.match(timeTagRegex);
                if (match) {
                    const min = parseInt(match[1], 10);
                    const sec = parseInt(match[2], 10);
                    const ms = match[3] ? parseInt((match[3] + (match[3].length === 1 ? '0' : '')).slice(0,3), 10) : 0;
                    const text = match[4].trim();
                    const timeInSeconds = min * 60 + sec + (ms / 1000);
                    parsed.push({ time: timeInSeconds, text: text });
                } else {
                    if (line.trim()) {
                        parsed.push({ time: null, text: line.trim() });
                    }
                }
            });
            parsed.sort((a, b) => {
                if (a.time === null) return 1;
                if (b.time === null) return -1;
                return a.time - b.time;
            });
            return parsed;
        }

        function renderLyrics(parsed) {
            const lyricsDiv = document.getElementById('lyrics');
            lyricsDiv.innerHTML = '';
            parsed.forEach((item, idx) => {
                const lineDiv = document.createElement('div');
                lineDiv.className = 'lyrics-line';
                lineDiv.textContent = item.text;
                if (item.time !== null) {
                    lineDiv.dataset.time = item.time;
                }
                lineDiv.dataset.idx = idx;
                lyricsDiv.appendChild(lineDiv);
            });
            window.currentLyricIndex = -1;
            lyricsDiv.scrollTop = 0;
        }

        function renderPlainLyrics(text) {
            const lyricsDiv = document.getElementById('lyrics');
            lyricsDiv.innerHTML = '';
            const paragraphs = text.split(/\r?\n\r?\n/);
            paragraphs.forEach((p, i) => {
                const div = document.createElement('div');
                div.className = 'lyrics-line';
                div.textContent = p.trim();
                div.dataset.idx = i;
                lyricsDiv.appendChild(div);
            });
        }

        function clearLyricsDisplay() {
            window.currentLyrics = [];
            window.currentLyricIndex = -1;
            stopLyricsSync();
            const lyricsDiv = document.getElementById('lyrics');
            if (lyricsDiv) lyricsDiv.innerHTML = '<em>No lyrics available</em>';
        }

        function startLyricsSync() {
            stopLyricsSync();
            const audioId = `audio${currentAudio}`;
            const handler = function() {
                if (!window.currentLyrics || window.currentLyrics.length === 0) return;
                if (!window.lyricsSyncEnabled) return;
                const t = this.currentTime;
                updateLyricsHighlight(t);
            };
            addEventListenerTracked(audioId, 'timeupdate', handler);
        }

        function stopLyricsSync() {
            currentEventListeners.forEach((listeners, audioId) => {
                const audio = document.getElementById(audioId);
                const remaining = [];
                listeners.forEach(({event, handler}) => {
                    if (event === 'timeupdate') {
                        try { audio.removeEventListener(event, handler); } catch(e) {}
                    } else {
                        remaining.push({event, handler});
                    }
                });
                if (remaining.length > 0) {
                    currentEventListeners.set(audioId, remaining);
                } else {
                    currentEventListeners.delete(audioId);
                }
            });
        }

        function updateLyricsHighlight(timeSeconds) {
            const lyricsDiv = document.getElementById('lyrics');
            if (!lyricsDiv) return;
            const parsed = window.currentLyrics || [];
            if (!parsed || parsed.length === 0) return;

            let idx = -1;
            for (let i = 0; i < parsed.length; i++) {
                if (parsed[i].time === null) continue;
                if (parsed[i].time <= timeSeconds) {
                    idx = i;
                } else {
                    break;
                }
            }

            if (idx === -1) {
                return;
            }

            if (idx === window.currentLyricIndex) return;

            const prev = lyricsDiv.querySelector('.lyrics-line.current');
            if (prev) prev.classList.remove('current');

            const newLine = lyricsDiv.querySelector(`.lyrics-line[data-idx="${idx}"]`);
            if (newLine) {
                newLine.classList.add('current');
                const offsetTop = newLine.offsetTop;
                const half = lyricsDiv.clientHeight / 2;
                lyricsDiv.scrollTop = Math.max(0, offsetTop - half);
            }

            window.currentLyricIndex = idx;
        }

        function toggleLyricsPanel() {
            const panel = document.getElementById('lyrics-panel');
            if (panel.classList.contains('hidden')) {
                panel.classList.remove('hidden');
            } else {
                panel.classList.add('hidden');
            }
        }

        function toggleLyricsSync() {
            const checkbox = document.getElementById('sync-lyrics');
            if (checkbox) {
                checkbox.checked = !checkbox.checked;
                window.lyricsSyncEnabled = checkbox.checked;
                if (window.lyricsSyncEnabled) {
                    startLyricsSync();
                } else {
                    stopLyricsSync();
                }
            } else {
                window.lyricsSyncEnabled = !window.lyricsSyncEnabled;
                if (window.lyricsSyncEnabled) startLyricsSync(); else stopLyricsSync();
            }
        }

        function loadPlaylistMetadata() {
            playlist.forEach((songPath, index) => {
                fetch(`/get_song_metadata/${encodeURIComponent(songPath)}`)
                    .then(response => response.json())
                    .then(data => {
                        if (!data.error) {
                            playlistMetadata[index] = data;
                        } else {
                            const fileName = songPath.split('/').pop().split('\\').pop();
                            playlistMetadata[index] = {
                                artist: 'Unknown Artist',
                                title: fileName,
                                album: 'Unknown Album',
                                duration: 0
                            };
                        }
                        updatePlaylistDisplay();
                    })
                    .catch(() => {
                        const fileName = songPath.split('/').pop().split('\\').pop();
                        playlistMetadata[index] = {
                            artist: 'Unknown Artist',
                            title: fileName,
                            album: 'Unknown Album',
                            duration: 0
                        };
                        updatePlaylistDisplay();
                    });
            });
        }

        function updatePlaylistDisplay() {
        //    if (playlist.length <= 1) return;

            const playlistSongsDiv = document.getElementById('playlist-songs');
            playlistSongsDiv.innerHTML = '';

            playlist.forEach((songPath, index) => {
                const songDiv = document.createElement('div');
                songDiv.className = 'playlist-song';

                if (index === currentIndex) {
                    songDiv.classList.add('current');
                } else if (playedSongs.has(index)) {
                    songDiv.classList.add('played');
                }

                const metadata = playlistMetadata[index];
                const songInfo = document.createElement('div');
                songInfo.className = 'song-info';

                if (metadata) {
                    const duration = metadata.duration > 0 ?
                        `${Math.floor(metadata.duration / 60)}:${(metadata.duration % 60).toString().padStart(2, '0')}` :
                        '';

                    songInfo.innerHTML = `
                        <span class="song-number">${index + 1}.</span>
                        <strong>${metadata.artist}</strong> - ${metadata.title}
                        ${metadata.album ? `<span style="color: #666;"> (${metadata.album})</span>` : ''}
                        ${duration ? `<span style="float: right; color: #666;">${duration}</span>` : ''}
                    `;
                } else {
                    const fileName = songPath.split('/').pop().split('\\').pop();
                    songInfo.innerHTML = `
                        <span class="song-number">${index + 1}.</span>
                        Loading... (${fileName})
                    `;
                }

                songDiv.appendChild(songInfo);
                songDiv.onclick = () => jumpToSong(index);
                playlistSongsDiv.appendChild(songDiv);
            });
        }

        function jumpToSong(index) {
            if (index < 0 || index >= playlist.length) return;
            if (isTransitioning) return; // Prevent jumps during transitions

            // Clean up all existing listeners and stop all audio
            removeAllEventListeners();
            
            const audio1 = document.getElementById('audio1');
            const audio2 = document.getElementById('audio2');
            
            audio1.pause();
            audio2.pause();
            audio1.currentTime = 0;
            audio2.currentTime = 0;

            // Reset states
            isTransitioning = false;
            crossfadeActive = false;
            silenceStartTime = null; // Reset gap killer state

            // Update current index
            currentIndex = index;

            // Play the selected song
            playCurrentSong();
        }

        function playSearchResults() {
            if (!window.searchResults || window.searchResults.length === 0) return;

            playlist = window.searchResults.map(song => song.path);
            currentIndex = 0;
            playedSongs.clear();
            playlistMetadata = [];
            isTransitioning = false;
            crossfadeActive = false;

            window.searchResults.forEach((song, index) => {
                playlistMetadata[index] = {
                    artist: song.artist,
                    title: song.title,
                    album: song.album,
                    duration: 0
                };
            });

            showPlayerSection();
            updatePlaylistDisplay();
           document.getElementById('playlist_name').innerHTML = ''
            playCurrentSong();
        }

        function playSearchResultsFrom(startIndex) {
            if (!window.searchResults || window.searchResults.length === 0) return;

            playlist = window.searchResults.map(song => song.path);
            currentIndex = startIndex;
            playedSongs.clear();
            playlistMetadata = [];
            isTransitioning = false;
            crossfadeActive = false;

            window.searchResults.forEach((song, index) => {
                playlistMetadata[index] = {
                    artist: song.artist,
                    title: song.title,
                    album: song.album,
                    duration: 0
                };
            });

            showPlayerSection();
            updatePlaylistDisplay();
            document.getElementById('playlist_name').innerHTML = ''
            playCurrentSong();
        }

        // List all songs (existing)
        function listSongs() {
            document.getElementById('status').innerHTML = '';
            hideAllSections();
            document.getElementById('list-section').classList.remove('hidden');
            const container = document.getElementById('all-songs-list');
            container.innerHTML = 'Fetching all songs it may take some time, please wait...';

            fetch('/list_songs')
                .then(r => r.json())
                .then(data => {
                    if (!Array.isArray(data)) {
                        container.innerHTML = 'Unexpected response format.';
                        return;
                    }
                    const albums = {};
                    data.forEach(song => {
                        const albumName = song.album || 'Unknown Album';
                        if (!albums[albumName]) albums[albumName] = [];
                        albums[albumName].push(song);
                    });

                    container.innerHTML = '';
                    Object.keys(albums).forEach(albumName => {
                        const albumDiv = document.createElement('div');
                        albumDiv.className = 'list-album';
                        const header = document.createElement('h4');
                        header.textContent = albumName;
                        albumDiv.appendChild(header);

                        albums[albumName].forEach(s => {
                            const songDiv = document.createElement('div');
                            songDiv.className = 'list-song';
                            songDiv.textContent = `${s.artist} - ${s.title} (${s.album || 'Unknown Album'})`;
                            songDiv.onclick = () => {
                                playSingleSong(s.path);
                            };
                            albumDiv.appendChild(songDiv);
                        });

                        container.appendChild(albumDiv);
                    });
                })
                .catch(err => {
                    console.error('Error listing songs:', err);
                    document.getElementById('all-songs-list').innerHTML = 'Error fetching songs.';
                });
        }

        // New: List Artists
        function listArtists() {
            document.getElementById('status').innerHTML = '';
            hideAllSections();
            document.getElementById('artists-section').classList.remove('hidden');
            const container = document.getElementById('artists-list');
            container.innerHTML = 'Fetching all artists it may take some time, please wait...';

            // Expected server response: [{ artist: "Artist Name" }, ... ]
            fetch('/list_artists')
                .then(r => {
                    if (!r.ok) throw new Error(`Server ${r.status} ${r.statusText}`);
                    return r.json();
                })
                .then(data => {
                    if (!Array.isArray(data)) {
                        container.innerHTML = 'Unexpected response format.';
                        console.error('list_artists returned:', data);
                        return;
                    }
                    container.innerHTML = '';
                    data.forEach(item => {
                        const div = document.createElement('div');
                        div.className = 'artist-item';
                        div.innerHTML = `<div class="artist-name">${item.artist}</div>`;
                        div.onclick = () => showArtistAlbums(item.artist);
                        container.appendChild(div);
                    });
                })
                .catch(err => {
                    console.error('Error listing artists:', err);
                    container.innerHTML = 'Error fetching artists: ' + err.message;
                });
        }

        // When clicking an artist: fetch and display albums and album covers grouped with songs
        // Expected endpoint: GET /artist_albums?artist=Artist%20Name
        // Expected response: [{ album: "Album Title", cover: "<base64-or-null>", songs: [{ title, path, duration, artist }, ...] }, ...]
        function showArtistAlbums(artist) {
            document.getElementById('status').innerHTML = '';
            hideAllSections();
            document.getElementById('artist-albums-section').classList.remove('hidden');
            document.getElementById('artist-name').textContent = artist;
            const container = document.getElementById('artist-albums-list');
            container.innerHTML = 'Loading albums, please wait...';

            fetch(`/artist_albums?artist=${encodeURIComponent(artist)}`)
                .then(r => {
                    if (!r.ok) throw new Error(`Server ${r.status} ${r.statusText}`);
                    return r.json();
                })
                .then(data => {
                    if (!Array.isArray(data)) {
                        container.innerHTML = 'Unexpected response format.';
                        console.error('artist_albums returned:', data);
                        return;
                    }
                    container.innerHTML = '';
                    if (data.length === 0) {
                        container.innerHTML = '<em>No albums found for this artist.</em>';
                        return;
                    }
                    data.forEach(album => {
                        const alb = document.createElement('div');
                        alb.className = 'album-item';
                        const imgSrc = album.cover ? `data:image/jpeg;base64,${album.cover}` : 'static/img/no-cover.png';
                        alb.innerHTML = `
                            <img src="${imgSrc}" class="album-cover" alt="Cover">
                            <div class="album-title">${album.album}</div>
                            <div class="album-artist" style="color:#666; font-size:0.9em;">${album.artist || artist}</div>
                        `;
                        alb.onclick = () => {
                            // display album songs and start playing them
                            if (album.songs && album.songs.length > 0) {
                                playAlbumSongs(album);
                            } else {
                                // fallback: fetch album songs endpoint if songs not included
                                fetchAlbumSongs(album.album, album.artist || artist);
                            }
                        };
                        container.appendChild(alb);
                    });
                })
                .catch(err => {
                    console.error('Error fetching artist albums:', err);
                    container.innerHTML = 'Error fetching albums: ' + err.message;
                });
        }

        function getLimitValue() {
            // 1. Get the value from the input field
            const limitInput = document.getElementById('limit');

            // 2. Convert the string value to an integer (number)
            // Use parseInt() with radix 10 to ensure it's treated as a decimal number.
            const limit = parseInt(limitInput.value, 10);

            // 3. Add a basic validation check
            if (isNaN(limit) || limit <= 0) {
                console.error("Invalid limit value. Please enter a positive number.");
                return 20; // Default to 20 or handle error display
        }

    return limit;
}

        function loadNextPage() {
            const limit = getLimitValue(); // Get the current limit to calculate the new offset
            offset += limit;
            listAlbums();
        }

        function loadPrevPage() {
            const limit = getLimitValue(); // Get the current limit to calculate the new offset
            offset -= limit;
            listAlbums();
        }

        // List Albums (all albums)
        // Expected server response: [{ album: "Title", artist: "Artist", cover: "<base64-or-null>" }, ...]

        function listAlbums() {
            document.getElementById('status').innerHTML = '';
            hideAllSections();
            document.getElementById('albums-section').classList.remove('hidden');
            const limit = getLimitValue(); // Get the current, parsed limit
            const container = document.getElementById('albums-list');
            const params = new URLSearchParams({
                limit: limit,
                offset: offset
            }).toString();
            container.innerHTML = 'Loading, it takes some time, please wait...';

            fetch(`/list_albums?${params}`)
                .then(r => {
                    if (!r.ok) throw new Error(`Server ${r.status} ${r.statusText}`);
                    return r.json();
                })
                .then(data => {
                    if (!container) {
                        console.error('HTML container element not found.');
                        return;
                    }
                    if (!Array.isArray(data)) {
                        container.innerHTML = 'Unexpected response format.';
                        console.error('list_albums returned:', data);
                        return;
                    }
                    container.innerHTML = '';
                    if (data.length === 0) {
                        container.innerHTML = '<em>No albums found.</em>';
                        return;
                    }
                    data.forEach(album => {
                        const alb = document.createElement('div');
                        alb.className = 'album-item';
                        const imgSrc = album.cover ? `data:image/jpeg;base64,${album.cover}` : 'static/img/no-cover.png';
                        alb.innerHTML = `
                            <img src="${imgSrc}" class="album-cover" alt="Cover">
                            <div class="album-title">${album.album}</div>
                            <div class="album-artist" style="color:#666; font-size:0.9em;">${album.artist || ''}</div>
                        `;
                        alb.onclick = () => {
                            // fetch and play album songs
                            fetchAlbumSongs(album.album, album.artist || '');
                        };
                        container.appendChild(alb);
                    });
                })
                .catch(err => {
                    console.error('Error listing albums:', err);
                    if (container) {
                    container.innerHTML = 'Error fetching albums: ' + err.message;
                    }
                });
        }

        // Fetch album songs via endpoint and play them (used by both artists and album lists)
        // Expected endpoint: GET /album_songs?album=Album%20Title&artist=Artist%20Name (artist optional)
        // Expected response: { album: "Title", artist: "Artist", cover: "<base64-or-null>", songs: [{ title, path, duration, artist }, ...] }
        function fetchAlbumSongs(albumName, albumArtistName) {
            const params = new URLSearchParams();
            params.append('album', albumName);
            if (albumArtistName) params.append('album_artist', albumArtistName);

            const container = document.getElementById('artist-albums-list') || document.getElementById('albums-list');
            if (container) container.innerHTML = 'Loading songs...';

            fetch(`/album_songs?${params.toString()}`)
                .then(r => {
                    if (!r.ok) throw new Error(`Server ${r.status} ${r.statusText}`);
                    return r.json();
                })
                .then(data => {
                    if (!data || !Array.isArray(data.songs)) {
                        console.error('album_songs returned unexpected:', data);
                        if (container) container.innerHTML = 'Unexpected response format.';
                        return;
                    }
                    // prepare playlist from album songs
                    const songs = data.songs;
                    playAlbumSongs({ album: data.album || albumName, artist: data.album_artist || albumArtistName, cover: data.cover, songs: songs });
                })
                .catch(err => {
                    console.error('Error fetching album songs:', err);
                    if (container) container.innerHTML = 'Error fetching album songs: ' + err.message;
                });
        }

        // Given an album object with songs, set playlist and start playback
        function playAlbumSongs(albumObj) {
            if (!albumObj || !Array.isArray(albumObj.songs)) return;
            playlist = albumObj.songs.map(s => s.path);
            currentIndex = 0;
            playedSongs.clear();
            playlistMetadata = [];
            isTransitioning = false;
            crossfadeActive = false;

            // Use metadata provided by album data if available
            albumObj.songs.forEach((s, idx) => {
                playlistMetadata[idx] = {
                    artist: s.artist || albumObj.artist || 'Unknown Artist',
                    title: s.title || s.name || s.path.split('/').pop(),
                    album: albumObj.album,
                    duration: s.duration || 0,
                };
            });

            // Update UI and start playback
            showPlayerSection();
            document.getElementById('playlist_name').innerHTML = `${albumObj.album_artist ? albumObj.album_artist + ' - ' : ''}${albumObj.album}`;
            updatePlaylistDisplay();

            // Pre-load album cover in metadata area if available
            if (albumObj.cover) {
                const metadataDiv = document.getElementById('metadata');
                // keep existing metadata but show album cover at top
                const existing = metadataDiv.innerHTML || '';
                const coverImg = `<img src="data:image/jpeg;base64,${albumObj.cover}" class="album-art"><br>`;
                metadataDiv.innerHTML = coverImg + existing;
            }

            playCurrentSong();
        }

        // Initialize gap killer controls when page loads
        document.addEventListener('DOMContentLoaded', function() {
            initializeGapKillerControls();

            const syncCheckbox = document.getElementById('sync-lyrics');
            if (syncCheckbox) {
                syncCheckbox.addEventListener('change', (e) => {
                    window.lyricsSyncEnabled = e.target.checked;
                    if (window.lyricsSyncEnabled) startLyricsSync();
                    else stopLyricsSync();
                });
            }
        });
    </script>
</body>
</html>